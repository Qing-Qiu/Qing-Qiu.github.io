{"meta":{"title":"秋刀鱼的博客","subtitle":"","description":"秋刀鱼","author":"Saury","url":"https://Qing-Qiu.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-02-10T14:07:08.000Z","updated":"2021-12-22T04:18:28.118Z","comments":false,"path":"categories/index.html","permalink":"https://qing-qiu.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-10T14:07:08.000Z","updated":"2021-12-21T17:37:04.329Z","comments":false,"path":"about/index.html","permalink":"https://qing-qiu.github.io/about/index.html","excerpt":"","text":"I’m sorry that I am Saury."},{"title":"标签","date":"2020-02-10T14:07:08.000Z","updated":"2021-12-21T17:36:11.735Z","comments":false,"path":"tags/index.html","permalink":"https://qing-qiu.github.io/tags/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-02-10T14:07:08.000Z","updated":"2021-12-21T17:36:29.006Z","comments":false,"path":"resources/index.html","permalink":"https://qing-qiu.github.io/resources/index.html","excerpt":"","text":""}],"posts":[{"title":"排列计数","slug":"Permutation-Count","date":"2021-12-12T11:14:18.000Z","updated":"2021-12-21T17:38:40.679Z","comments":true,"path":"2021/12/12/Permutation-Count/","link":"","permalink":"https://qing-qiu.github.io/2021/12/12/Permutation-Count/","excerpt":"","text":"题目链接：暂无 题目描述求有多少种长度为 n 的序列 A，满足以下条件： 1∼n 这 n 个数在序列中各出现了一次； 若第 i 个数 Ai 的值为 i，则称 i 是稳定的。序列恰好有 m 个数是稳定的。满足条件的序列可能很多，序列数对 10 ^ 9 + 7 取模。 输入：第一行一个数 T，表示有 T 组数据。接下来 T 行，每行两个整数 n、m。 输出：输出 T 行，每行一个数，表示求出的序列数。 样例输入151 01 15 2100 5010000 5000 样例输出1012057802888760695423 题解部分12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const long long k=1e9+7;long long cp[1000020],jc[1000020],ny[1000020];int f(long long a,long long b) //快速幂模板&#123; long long ans = 1; while (b&gt;0) &#123; if (b%2==1) ans=ans*a%k; b/=2; a=a*a%k; &#125; return ans;&#125;int main()&#123; cp[0]=1,cp[2]=1; for (int i=3;i&lt;=1000000;i++) cp[i]=(i-1)*(cp[i-1]+cp[i-2])%k;//cp即由错排公式从第0~n个元素组成的数组 jc[0]=1,jc[1]=1; for (int i=2;i&lt;=1000000;i++) jc[i]=jc[i-1]*i%k;//jc即阶乘 ny[0] =f(jc[0],k - 2); for (int i=1;i&lt;=1000000;i++) ny[i]=f(jc[i],k-2)%k;//ny即逆元 int t; cin&gt;&gt;t; for (int i=1;i&lt;=t;i++) &#123; long long n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;(jc[n]*ny[m]%k*ny[n-m]%k*cp[n-m])%k&lt;&lt;endl; &#125; return 0;&#125; 解释第一次遇见它是在开学暑假的精弘正式赛第二次遇见它是在某一次ACM打卡活动我觉得这道题的知识点非常有趣错排公式我高中就接触过，0 1 2 9 44 265 我对这个数列非常喜欢2=(0+1)*29=(1+2)*344=(2+9)*4265=(9+44)*5a[n]=(a[n-1]+a[n-2])*(n-1)至于通项公式也可以推一推或者上网搜一搜这道题不用经过思考就可以看出是其中的m个数在原来的位置，剩下的(n-m)个数进行了错排也就是C(m,n)*a[n-m]但这个数据很大，题目说需要取模那我们很容易就把阶乘和错排的数组边乘边取模给做完了C(m,n)中有一步除以(n-m)!的过程该怎么办呢？这时我们想到可以求逆元费马小定理是指如果p是一个质数，而整数a不是p的倍数，则有a^(p-1) ≡ 1 (mod p)由费马小定理可知a * a ^ (p-2) ≡ 1 (mod p)a ^ (p-2) ≡ 1/a (mod p)因此可知逆元就是a^(p-2)%p因此我们做了一个存放逆元的数组是不是直接输出就好了呢？我们试了一下发现TLE因此快快用上快速幂模板来加快我们求逆元的速度快速幂这个算法体现了分治的思想把每次的乘方拆成两半来解决速度一下子就减了不少我们试着交了一下，AC！ 收获 学到了快速幂模板 学到了用费马小定理推得的逆元，成功解决了除法取模的问题。","categories":[],"tags":[{"name":"solved","slug":"solved","permalink":"https://qing-qiu.github.io/tags/solved/"}]},{"title":"正确括号序列编辑器(Correct Bracket Sequence Editor)","slug":"CBSE","date":"2021-12-12T09:35:00.000Z","updated":"2021-12-22T06:14:31.772Z","comments":true,"path":"2021/12/12/CBSE/","link":"","permalink":"https://qing-qiu.github.io/2021/12/12/CBSE/","excerpt":"","text":"题目链接：洛谷 Codeforces 题目描述最近，Polycarp开始开发一种仅适用于正确括号序列（缩写为CBS）的文本编辑器。请注意，如果可以通过添加“+”-s和“1”-s来获得正确的数学表达式，则括号序列是正确的。例如，序列“（（））（）”“（）”和“（（）（（）））”是正确的，而“）（”“（（）”和“（（）））（”是不正确的。CBS中的每个括号都有一对。例如，在“（（）（（）））”中：第1个括号与第8个括号配对，第2个括号与第3个括号配对，第3个括号与第2个括号配对，第4个括号与第7个括号配对，第5个括号与第6个括号配对，第6个括号与第5个括号配对，第7个括号与第4个括号配对，第8个括号与第1个括号配对。Polycarp的编辑器目前在使用CBS期间仅支持三种操作。编辑器中的光标占据其中一个括号的整个位置（而不是括号之间的位置！）。支持三种操作：«L»-将光标向左移动一个位置，«R»-将光标向右移动一个位置，«D»-删除光标所在的括号，删除与其配对的括号以及它们之间的所有括号（即，删除光标所在的括号和与其配对的括号之间的子字符串）。操作“D”后，光标移动到最右边的括号中（当然，在未删除的括号中）。如果没有这样的括号（即，CBS的后缀已被删除），则光标将移动到最靠近左侧的括号（当然，在未删除的括号中）。下面的图片说明了操作“D”的几种用法。 Polycarp的编辑器不支持所有不正确的操作（将光标移到CBS的末尾，删除整个CBS等）。Polycarp对他的开发感到非常自豪，你能实现他的编辑器的功能吗？ 输入：第一行包含三个正整数n、m和p（2≤N≤500000, 1≤M≤500000, 1≤P≤n）——正确括号顺序中括号的数量、操作的数量和光标的初始位置。序列中的位置从左到右编号，从1开始。保证n是偶数。它后面是由n个字符组成的字符串“（“和”）”，构成正确的括号序列。然后跟随一个由m个字符组成的字符串“L”“R”和“D”——一系列操作。从第一个到最后一个，一个接一个地进行操作。可以保证给定的操作不会将光标移到括号序列之外，并且在所有操作之后，括号序列将是非空的。 输出：打印正确的括号顺序，这是对初始顺序应用所有操作后获得的结果。 样例输入18 4 5(())()()RDLD 样例输出1() 样例输入212 5 3((()())(()))RRDLD 样例输出2(()(())) 样例输入38 8 8(())()()LLLLLLDD 样例输出3()() 提示：在第一个样例中，光标最初位于位置5。考虑编辑的过程：命令“R”-光标移动到右侧的位置6；命令“D”-从位置5到位置6删除括号。在CBS采取形式（（））（）之后，光标位于位置5；命令“L”-光标移动到左侧的位置4；命令“D”-从位置1到位置4删除括号。在CBS采用（）形式之后，光标位于位置1。因此，答案等于（）。 题解部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m,p; char c; list&lt;char&gt; a; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; a.push_back(&#x27;!&#x27;); //在链表头设置围栏 for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;c; a.push_back(c); &#125; list&lt;char&gt;::iterator it; list&lt;char&gt;::iterator posBeg,posEnd; //所要删除的起始位和终止位 list&lt;char&gt;::iterator temp; it=a.begin(); it++; //起始值为原起始值后面一位 for (int i=2;i&lt;=p;i++) it++; //后移至p位 for (int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;c; if (c==&#x27;R&#x27;) it++; //R指令右移一位 if (c==&#x27;L&#x27;) it--; //L指令左移一位 if (c==&#x27;D&#x27;) &#123; if (*it==&#x27;(&#x27;) &#123; //D指令判断是否左括号 posBeg=it; //所要删除的起始位在当前位置 posEnd=it; posEnd++; int cnt=1; //当前位置为(所以要向右移 for (temp=posEnd;temp!=a.end();temp++) &#123;//从起始位后面一位开始找 if (*temp==&#x27;(&#x27;) cnt++; //遇到(叠加计数器+1 if (*temp==&#x27;)&#x27;) cnt--; //遇到)抵消计数器-1 if (cnt==0) break; //匹配结束，退出 &#125; posEnd=temp; //把所要删除的终止位赋值给posEnd posEnd++; temp=posEnd; if (temp==a.end()) //下一次操作后光标的重定位 it--; //如果所要删除的终止位后面是NULL，就定位到之前起始位前面一位 else it=temp; //否则就定位到所要删除的终止位后面一位 for (temp=posBeg;temp!=posEnd;) //删 a.erase(temp++); &#125; else if (*it==&#x27;)&#x27;) &#123; //D指令判断是否右括号 posBeg=it; posEnd=it; //所要删除的终止位在当前位置 posBeg--; int cnt=1; //当前位置为)所以要向左移 for (temp=posBeg;temp!=a.begin();temp--) &#123;//从终止位前面一位开始找 if (*temp==&#x27;)&#x27;) cnt++; //遇到)叠加计数器+1 if (*temp==&#x27;(&#x27;) cnt--; //遇到(抵消计数器-1 if (cnt==0) break; //匹配结束，退出 &#125; posBeg=temp; //把所要删除的起始位赋值给posBeg posEnd++; temp=posEnd; if (temp==a.end()) &#123;//下一次操作后光标的重定位 it=posBeg; it--; //如果所要删除的终止位后面是NULL，就定位到之前起始位前面一位 &#125; else it++; //否则就定位到所要删除的终止位后面一位 for (temp=posBeg;temp!=posEnd;) //删 a.erase(temp++); &#125; &#125; &#125; temp=a.begin(); temp++; //第一位是围栏 for (it=temp;it!=a.end();it++) cout&lt;&lt;*it; return 0;&#125; 花絮&amp;起因由于Titan让我做翻译&amp;做测试数据于是我生产了以下不忍直视的随机数生成程序 好玩の随机数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand((int)time(0)); int n,m,p; n=rand()%250; n*=2; m=rand()%100; m*=2;// n=rand()%250000;// n=n*2;// m=rand()%250000;// m=m*2; p=rand()%n; cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;m&lt;&lt;&#x27; &#x27;&lt;&lt;p&lt;&lt;endl; int cnt; string s; do &#123; cnt=0; s=&quot;&quot;; for (int i=1;i&lt;=n;i++) &#123; char c; c=&#x27;(&#x27;+rand()%2; if (c==&#x27;(&#x27;) cnt++; else cnt--; if (cnt==-1) &#123; cnt+=2; c=&#x27;(&#x27;; &#125; s=s+c; &#125; &#125;while (cnt!=0); cout&lt;&lt;s&lt;&lt;endl; //直到找到匹配的括号位置（懒人方法） for (int i=1;i&lt;=m;i++) &#123; int k=rand()%3; if (k==0) cout&lt;&lt;&quot;L&quot;; else if (k==1) cout&lt;&lt;&quot;R&quot;; else cout&lt;&lt;&quot;D&quot;; &#125; //并没有判定迭代器是否飞出去 cout&lt;&lt;endl; return 0;&#125; 心得&amp;解释 题目很长，翻译成中文1100字，不过废话很多。 狠狠地体验了迭代器的运用。并使用了对头部和尾部的特殊操作。 coding完之后，过了样例以后有点开心，交上去TLE的绝望。之后想挣扎，把整个程序写了个注释，还是没有AC。之后询问了某位大佬，他告诉我是迭代器失效的问题。（虽然这个问题我在前面部分尽力规避了，但还是在最后erase的部分出了岔子。把for()中的递增语句移到循环体中，就可以防止迭代器失效的问题。） 在制作数据的过程中，学到了随机数、文件读写的运用。难点是括号部分完全匹配以及题中的三个指令使得指针不越界。我在随机数生成程序中完成了用循环强制进行括号匹配，由于我源代码的特性，使得指针越界操作直接使程序无法运行，可以保证生成的指令序列合法。由于能力有限，随机数n&lt;500,m&lt;100。再下去我随机数生成程序的效率也不够高了。","categories":[],"tags":[{"name":"solved","slug":"solved","permalink":"https://qing-qiu.github.io/tags/solved/"}]},{"title":"我的第一篇博客","slug":"blog0","date":"2021-12-12T04:12:12.000Z","updated":"2021-12-21T17:38:25.124Z","comments":true,"path":"2021/12/12/blog0/","link":"","permalink":"https://qing-qiu.github.io/2021/12/12/blog0/","excerpt":"","text":"这是我第一篇博客。我就在这里放一些我平常学习用的网站以及一些我觉得有意思的网站。 吾爱破解 bilibili 洛谷 力扣 拼题A Codeforces 51nod CSDN cppreference 杭电OJ 菜鸟教程 慕课 VirtualJudge ProjectEuler 再来放一个经典a+b程序12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"solved","slug":"solved","permalink":"https://qing-qiu.github.io/tags/solved/"}]}